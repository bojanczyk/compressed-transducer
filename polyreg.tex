\section{Polyregular functions}
\label{sec:polyregular}

Having shown that the rational and regular functions are compatible with compression, we now turn to a more expressive class of functions, namely the polyregular functions. We will show that this class is \emph{not} compatible with compression, and we will isolate a fragment that is. 

Similarly to the rational and regular functions discussed in the previous section, the class of  polyregular functions admits many characterizations, see the survey~\cite{polyregular-survey} for at least five such characterizations. For the purposes of this paper, it will be most convenient to work with a characterization using combinators, similar to the one from Theorem~\ref{thm:regular-def}. The idea is to extend the description from Theorem~\ref{thm:regular-def} with one more basic function, which is explained in the following example. 

\begin{myexample} [Marked squaring] \label{ex:marked-squaring} The \emph{marked squaring} function is like the  square function  from Example~\ref{ex:squaring}, except that each copy of the input string is annotated with an underlined position, with the $i$-th copy having the $i$-th position underlined.  Here is an example: 
\begin{align*}
1234 \quad \mapsto \quad \underline{1}234 1\underline{2}34 12\underline{3}4 123\underline{4}
\end{align*}
Formally speaking, the output alphabet is two copies of the input alphabet, one with and one without underlining.
\end{myexample}

The marked squaring function is an example of a polyregular function, and in fact the class of polyregular functions can be defined by adding marked squaring to the definition of regular functions from Theorem~\ref{thm:regular-def}. As we show below, marked squaring is not compatible with compression, which implies that not all polyregular functions are compatible with compression.



\begin{lemma}\label{lem:nonblind-squaring}
    Marked squaring is not compatible with compression.
\end{lemma}
\begin{proof}
    Similarly to Example~\ref{ex:exp-output}, the problem is not in computing the output compression, but simply in the fact that it does not exist in polynomial size. Consider an input string of the form 
    \begin{align*}
    a^{2^n}b.
    \end{align*}
    This string has a compression of linear size. We will show, however, that the output of marked squaring does not have any compression of subexponential size. The reason is that the output string contains an infix of the form  $ba^i\underline a$ for every $i \in \set{1,\ldots,{2^n}}$. On the other hand, the number of such infixes is limited by the size of any compression, as shown in the following claim.
    \begin{claim}
        Let $a,b,c$ be distinct letters. If a string $w$ has a compression of size $m$, then 
        \begin{align*}
        |\setbuild{ i }{$w$ contains an infix of the form $ab^ic$}| \leq m.
        \end{align*}
    \end{claim}
    \begin{proof}
        Consider a variable \texttt{x} in a straight line program, for which the corresponding rule is \texttt{x := y$\cdot$z}, where each of \texttt y and \texttt z is either a previously defined variable, or a letter, or the empty string $\varepsilon$.  Define the \emph{contribution} of variable \texttt{x} to be 
        \begin{align*}
        \setbuild{ i }{$ab^ic$ is an infix of \texttt x, but is not an infix of \texttt y or \texttt z}.
        \end{align*}
        The key observation is that this contribution contains at most one number $i$. This will imply the claim, since the set in the claim is the union of all contributions of variables in the program.  To see why the variable contributes at most one number, observe that the infix $ab^ic$ is either contained in \texttt y, or contained in \texttt z, or it crossed the boundary between \texttt y and \texttt z. In the first two cases, it is not counted in the contribution of \texttt x. In the last case, there is exactly one value of $i$ for which this can happen, namely the number of $b$'s between the last $a$ in \texttt y and the first $c$ in \texttt z.
    \end{proof}

\end{proof}

The above lemma proves that some polyregular functions are not compatible with compression. A natural idea to overcome this problem is to consider the weaker notion of squaring from Example~\ref{ex:squaring},
\begin{align*}
123 \quad \mapsto \quad 123123123,
\end{align*}
which does not have the underlines, and which is compatible with compression. We can, however, do a bit better. 

\begin{myexample}[Rectangle] \label{ex:strength}  The essential idea behind this function is that it takes a lexicographic product of two input strings, as illustrated in the following example:
    \begin{align}
        \label{eq:rectangle}
    (123,abcd) \quad \mapsto \quad 1abcd2abcd3abcd4abcd.
    \end{align}
    This can be seen as a generalization of squaring, since squaring is obtained by taking both input strings to be the same.
Since for the moment we want to work with functions that input strings (and not pairs of strings), we will view the  rectangle function as a string-to-string function in the following way. There are two disjoint alphabets $A$ and $B$, and the function has  type 
    \begin{align*}
    (A+B)^* \to (A+B)^*.
    \end{align*}
If the input is not of the form $A^*B^*$, then the output is the empty string. Otherwise, the input is split into two strings, and then we apply the rectangle operation as above. (An alternative definition, which would not change the results below, would be to untangle the input string over alphabet $A+B$ into two strings, by projecting onto the respective alphabets. We choose the previous definition to underline the fact that we are only interested in inputs where the two parts are clearly separated.)

    Let us show that the rectangle function is compatible with compression. Suppose that we are given a compression of some string over alphabet $A+B$. We can first check in polynomial time if this string is in $A^*B^*$; this can be done  because regular languages can be evaluated in polynomial time on compressed inputs. Next, we extract in polynomial time compressions for the two parts of the input string, one in $A^*$ and one in $B^*$; this can be done by removing the nonterminals from the unused part of the alphabet.  Finally, in the compression for the first  string from $A^*$, we append a copy of the compression for the second string from $B^*$ after each terminal symbol. 
\end{myexample}

As we have mentioned after Theorem~\ref{thm:regular-compatible}, adding any function compatible with compression to the basic functions in the theorem will lead a class that is compatible with compression. We believe -- with some justification presented in Section~\ref{sec:functional-lang} --  that the particular choice of the rectangle function is worthwhile, which leads us to the following definition. 
\begin{definition}[Weak polyregular functions]\label{def:weak-polyregular}
    Define the class of \emph{weak polyregular functions} to be the smallest class of string-to-string functions which:
    \begin{enumerate}
        \item contains all rational functions;
        \item contains the duplication, reverse and rectangle functions from Examples~\ref{ex:duplication},~\ref{ex:reversal} and~\ref{ex:strength};
        \item is closed under composition of functions;
        \item is closed under the map combinator from Lemma~\ref{lem:map}.
    \end{enumerate}
\end{definition}

The above class is a contained in the polyregular functions (we will show in a moment that the containment is strict). This is because the rectangle function is polyregular, and the polyregular functions have all the other closure properties from the definition above. In the above definition, duplication is redundant. This is because it can be simulated using rectangles, by first prepending $12$ to the input string. Also, we could eliminate reverse, by using a variant of the rectangle function in which the word from $B^*$ is reversed. However, we do not apply these optimisations, in order to underline the analogy with Theorem~\ref{thm:regular-def}.

By design, the weak polyregular functions are compatible with compression, which is proved using the same argument as for regular functions in Theorem~\ref{thm:regular-compatible}.

\begin{theorem}
    \label{thm:polyregular-compatible}
    Weak polyregular functions are compatible with compression.
\end{theorem}



One corollary of Theorem~\ref{thm:polyregular-compatible} is that the weak polyregular functions are a proper subclass of the polyregular functions, since the latter are not necessarily compatible with compression, as shown by Lemma~\ref{lem:nonblind-squaring}. This is stated in the following theorem, which also relates the classes to another known subclass of the polyregular functions, namely the comparison-free polyregular functions from~\cite{NguyenNP21} (this model  will be explained in the proof of the theorem).

\begin{theorem}\label{thm:inclusions-on-classes} Comparison-free polyregular $\subsetneq$ weak polyregular $\subsetneq$ polyregular.
\end{theorem}
\begin{proof}
    We have already argued for the second inclusion and its strictness. Let us now define the class of comparison-free polyregular functions, and argue for the first inclusion. One of the definitions of this class, see~\cite[Theorem 6.1]{NguyenNP21}, is the same as in Definition~\ref{def:weak-polyregular}, except that  the map combinator is not included\footnote{Strictly speaking, \cite[Theorem 6.1]{NguyenNP21} uses does not use the rectangle function, but a similar one called \emph{comparison-free squaring}. It is not hard to see that each of these two functions can be defined using the other. }. This proves the first inclusion. This inclusion is also strict, since  the comparison-free polyregular functions are not closed under map, see~\cite[Corollary 8.5]{NguyenNP21}.
\end{proof}

\paragraph*{A normal form.} We finish this section with slightly different characterization of the weak polyregular functions, which does not use the map combinator in the closure properties, only composition. 
In the definition of the weak polyregular functions from Definition~\ref{def:weak-polyregular}, map and function composition could be applied in alternation, e.g.~we could apply  map, followed by composition, followed by map, etc. The following lemma shows that such alternation is not necessary, since it is enough to compose functions, each of which is either rational, or map reverse, or map rectangle. Here, map reverse refers to the function obtained by applying the map combinator to the reverse function, and similarly for map rectangle. In other words, map can be pushed inside composition, and it only needs to be used once.

            \begin{lemma}\label{lem:map-normal-form}
                Every weak polyregular function can be obtained as a composition of functions, each of which is either: (a) rational; or (b) map reverse; or (c) map rectangle.  
    \end{lemma}
    \begin{proof}
        It is enough to show that the class of functions in the statement of the lemma has the necessary closure properties. It contains all rational functions, and it is closed under composition. It also contains reverse and rectangle, since these are subsumed by map reverse and map rectangle in the case where the separator symbol is not used. As we have remarked after Definition~\ref{def:weak-polyregular}, we can also recover duplication, which can be obtained as follows: 
        \begin{align*}
        w 
        \qquad \stackrel{\text{rational}}\mapsto \qquad 
        12w 
        \qquad \stackrel{\text{rectangle}}\mapsto \qquad 
1w2w 
        \qquad \stackrel{\text{rational}}\mapsto \qquad  \mapsto ww.
        \end{align*}
        
        It remains to show that the class is closed under applying map. Map commutes with composition, and therefore it is enough to show that map can be applied to the atomic functions (a), (b), (c). In other words, it is easy to see that map can be pushed inside composition, but it remains to be argued that it does not need to be applied twice.  The class of rational functions is closed under applying map, and therefore we only need to show that applying map twice to reverse or rectangle  yields  a function as in the statement of the lemma. We only do the case of the rectangle, and we leave the case of reverse to the reader.  
        
        Suppose then that we apply map twice to the rectangle function. In this case, there are two separators: one for the outer map (which we denote using a vertical bar) and one for the inner map (which we denote using a comma). 
        Here is an example 
        \begin{align*}
        a01,bc234|de56|fg78,hij9  \quad \mapsto \quad 
        a01,b234c234|d56e56|f78g78,h9i9j9.
        \end{align*}
        This is implemented by using a map rectangle where  both kinds of separator are treated in the same way. Formally speaking, we need to introduce a third separator (say $\#$), which is appended to both kinds of a separator using a rational function, as in the following example:
                \begin{align*}
                    a01,bc234|de56|fg78,hij9  \quad \mapsto \quad
                    a01,\#bc234|\#de56|\#fg78,\#hij9 .
        \end{align*}
        Next, we apply map rectangle with the new separator. This gives us essentially the correct output, except that the squares have an extra iteration, and there are many copies of the new separator.
        The result can then be cleaned up using a regular function, in order to obtain the correct output.
    \end{proof}
