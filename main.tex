\documentclass{article}


\usepackage{macros}


\begin{document}

\title{Transducers on compressed strings}
\maketitle


\paragraph{Algorithms on compressed data.}

Data compression is a core technology in computer science that has gained additional importance in the era of big data.
For an introduction into classical compression techniques see  \cite{Say00}. 
The primary motivation for this work stems from the paradigm of {\em algorithmics on compressed data}. 
Its principal idea is to process data that is given in compressed form without first decompressing it and then operating on the uncompressed data.
There are three main applications for algorithms of this kind (see  \cite{Loh12survey} for references).
\begin{itemize}
\item  In many areas, large data have to be not only stored
in compressed form, but the original (uncompressed) data has to be
processed and analyzed as well. 
In such cases, it makes sense to design algorithms that directly
operate on the compressed data in order to
save the time and space for (de)compression. 
A typical example is the search for specific patterns in genomes that are
stored in a compressed way.
\item In some situations it makes sense to compute in a first
phase a compressed representation of the input data, which makes
regularities explicit. These regularities may be exploited in
a second phase for speeding up an algorithm. This principle is 
known as {\em acceleration by compression}. 
\item Large and often highly compressible data may appear as 
intermediate data structures in algorithms. In such a situation, one may try to 
store a compressed representation of these intermediate data structures
and to process this representation. This may lead to more efficient 
algorithms. Examples for this strategy can be found for instance
in computational topology or group theory; see e.g \cite{}.
\end{itemize}
For a formal investigation of algorithmics on compressed data, due aspects have to be clarified: 
What compressed representation of data is used and what are the processing steps carried out 
on the compressed data? 

\paragraph{Grammar-based string compression.}
Let us first address the first question. In this paper we consider strings (words) that are compressed using context-free grammars: a \emph{compression} of a string $w \in A^*$ is a context-free grammar which generates the string $w$ and no other strings.  An equivalent representation is a \emph{straight line program}, which is a sequence of instructions that assign values to variables, using concatenation and constants, as in the following example:
\begin{lstlisting}
    x := 'a' 
    y := x $\cdot$ x
    z := y $\cdot$ y
\end{lstlisting}
The variables can be seen as non-terminals, and the last line can be seen as the starting non-terminal. The above program generates the string $aaaa$. A program with $n$ lines can generate a string of length up to $2^n$.

\paragraph{String-to-string function.}
The most general setting processing compressed strings would be to allow arbitrary
 \emph{string-to-string functions}. A  string-to-string function is a function $f : A^* \to B^*$ where $A$ and $B$ are finite alphabets. 
We are interested in string-to-string functions that can be evaluated using compressions, i.e.~given a compression of the input, one can return a compression of the output, in deterministic polynomial time. This is described in the following definition.

\begin{definition}
    A string-to-string function $f : A^* \to B^*$ is called \emph{compatible with compression} if there is a deterministic polynomial time algorithm which does this: 
    \begin{itemize}
        \item \textbf{Input:} a compression of a string $w \in A^*$.
        \item \textbf{Output:} a compression of the string $f(w) \in B^*$.
    \end{itemize}
\end{definition}
% \begin{definition}[Compression lifting]
%     For a string-to-string function 
%     \begin{align*}
%     f : \Sigma^* \to \Gamma^*,
%     \end{align*} a  \emph{compression lifting} is any   $f'$ which makes the following diagram commute:
% \[
% \begin{tikzcd}
% \text{compressipon of $\Sigma^*$}
% \ar[r,"f'"]
% \ar[d,"\text{uncompress}"']
% &
% \text{compressions of $\Gamma^*$}
% \ar[d,"\text{uncompress}"]
% \\
% \Sigma^*
% \ar[r,"f"']
% & 
% \Gamma^*
% \end{tikzcd}
% \]
% We say that $f$ is \emph{compatible with compression} if it has a compression lifting which is computable in deterministic polynomial time.
% \end{definition}

Let us begin with some examples of functions that are compatible with compression, and some that are not. In the examples, we use straight line programs as the representation of compressions.

\begin{myexample}[Duplication]\label{ex:duplication}
    The string duplication function $w \mapsto ww$ is compatible with compression. The corresponding operation on straight line programs is to append one more line \texttt{x := y $\cdot$ y}, where \texttt{y} was the last variable used in the input program. 
\end{myexample}

\begin{myexample}[Reversal]\label{ex:reversal}
    String reversal is also compatible with compression. The corresponding operation on straight line programs is to reverse the order of concatenation in every line. 
\end{myexample}

\begin{myexample}[Squaring]\label{ex:squaring}
  Consider the squaring function illustrated as follows:
\begin{align*}
    123 \quad \mapsto \quad 123123123.
\end{align*}
This function  is compatible with compression. To implement squaring on  straight line programs, we write the code of the program twice, with the second copy using the output of the first copy instead of the character constants. 
\end{myexample}

\begin{myexample}[Exponential outputs] \label{ex:exp-output} This is a non-example, i.e.~a function that is not compatible with compression.
    Assume that the input and output alphabets have one letter only, and consider the function 
    \begin{align*}
    a^n \quad \mapsto \quad a^{2^n}.
    \end{align*}
    This function is not compatible with compression. The reason is that we can encode an input string of length $2^n$ using a straight line program with $n$ lines. The output string will be of doubly exponential length, and will therefore require a compression of exponential size. Such a compression cannot be constructed in polynomial time. 
\end{myexample}



\input{linreg}

\input{polyreg}

\input{combinators}
\input{blind}

\nocite{bojanczyk_recobook}
\bibliographystyle{plain}
\bibliography{bib}



\end{document}
