\documentclass{article}


\usepackage{macros}


\begin{document}

\title{Transducers on compressed strings}
\maketitle
In this paper, we investigate transducers that operate on compressed strings. The compression in question is grammar based compression: a \emph{compression} of a string $w \in A^*$ is a context-free grammar which generates the string $w$ and no other strings.  An equivalent representation is \emph{straight line program}, which is a sequence of instructions that assign values to variables, using concatenation and constants, as in the following example:
\begin{lstlisting}
    x := 'a' 
    y := x $\cdot$ x
    z := y $\cdot$ y
\end{lstlisting}
The variables can be seen as non-terminals, and the last line can be seen as the starting non-terminal. The above program generates the string $aaaa$. A program with $n$ lines can generate a string of length up to $2^n$.

In this paper, a \emph{string-to-string function} is any function $f : A^* \to B^*$ where $A$ and $B$ are finite alphabets. 
We are interested in string-to-string functions that can be evaluated using compressions, i.e.~given a compression of the input, one can return a compression of the output, in deterministic polynomial time. This is described in the following definition.


\begin{definition}
    A string-to-string function $f : A^* \to B^*$ is called \emph{compatible with compression} if there is a deterministic polynomial time algorithm which does this: 
    \begin{itemize}
        \item \textbf{Input:} a compression of a string $w \in A^*$.
        \item \textbf{Output:} a compression of the string $f(w) \in B^*$.
    \end{itemize}
\end{definition}
% \begin{definition}[Compression lifting]
%     For a string-to-string function 
%     \begin{align*}
%     f : \Sigma^* \to \Gamma^*,
%     \end{align*} a  \emph{compression lifting} is any   $f'$ which makes the following diagram commute:
% \[
% \begin{tikzcd}
% \text{compressipon of $\Sigma^*$}
% \ar[r,"f'"]
% \ar[d,"\text{uncompress}"']
% &
% \text{compressions of $\Gamma^*$}
% \ar[d,"\text{uncompress}"]
% \\
% \Sigma^*
% \ar[r,"f"']
% & 
% \Gamma^*
% \end{tikzcd}
% \]
% We say that $f$ is \emph{compatible with compression} if it has a compression lifting which is computable in deterministic polynomial time.
% \end{definition}

Let us begin with some examples of functions that are compatible with compression, and some that are not. In the examples, we use straight line programs as the representation of compressions.

\begin{myexample}[Duplication]\label{ex:duplication}
    The string duplication function $w \mapsto ww$ is compatible with compression. The corresponding operation on straight line programs is to append one more line \texttt{x := y $\cdot$ y}, where \texttt{y} was the last variable used in the input program. 
\end{myexample}

\begin{myexample}[Reversal]\label{ex:reversal}
    String reversal is also compatible with compression. The corresponding operation on straight line programs is to reverse the order of concatenation in every line. 
\end{myexample}

\begin{myexample}[Squaring]\label{ex:squaring}
  Consider the squaring function illustrated as follows:
\begin{align*}
    123 \quad \mapsto \quad 123123123.
\end{align*}
This function  is compatible with compression. To implement squaring on  straight line programs, we write the code of the program twice, with the second copy using the output of the first copy instead of the character constants. 
\end{myexample}

\begin{myexample}[Exponential outputs] \label{ex:exp-output} This is a non-example, i.e.~a function that is not compatible with compression.
    Assume that the input and output alphabets have one letter only, and consider the function 
    \begin{align*}
    a^n \quad \mapsto \quad a^{2^n}.
    \end{align*}
    This function is not compatible with compression. The reason is that we can encode an input string of length $2^n$ using a straight line program with $n$ lines. The output string will be of doubly exponential length, and will therefore require a compression of exponential size. Such a compression cannot be constructed in polynomial time. 
\end{myexample}



\input{linreg}

\input{polyreg}

\input{combinators}
\input{blind}

\nocite{bojanczyk_recobook}
\bibliographystyle{plain}
\bibliography{bib}



\end{document}
